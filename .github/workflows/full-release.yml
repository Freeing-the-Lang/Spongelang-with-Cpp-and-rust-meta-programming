name: "üî• SpongeLang Full Build ‚Äî Auto Generate + Rust Macro + C++ Meta + NASM + Release"

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write


jobs:
  build:
    name: "üèóÔ∏è Auto Generate + Compile (Rust Macro + C++ Meta + NASM)"
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]


    steps:
      - name: Checkout
        uses: actions/checkout@v4


      #####################################################################
      # üî• 1. SpongeLang Compiler Ï†ÑÏ≤¥ Source ÏûêÎèô ÏÉùÏÑ±
      #####################################################################
      - name: "Generate SpongeLang Compiler Files"
        shell: bash
        run: |
          mkdir -p src/backend include examples

          ###############################################################
          # main.rs
          ###############################################################
          cat << 'EOF' > src/main.rs
mod tokenizer;
mod ast;
mod parser;
mod semantic;
mod backend;

use tokenizer::Tokenizer;

fn main() {
    let input = std::fs::read_to_string("examples/hello.sp")
        .expect("Failed to read file");

    let tokens = Tokenizer::new(&input).tokenize();
    println!("Tokens: {:?}", tokens);
}
EOF

          ###############################################################
          # tokenizer.rs
          ###############################################################
          cat << 'EOF' > src/tokenizer.rs
#[derive(Debug, Clone)]
pub enum Token {
    Ident(String),
    Number(String),
    LParen,
    RParen,
    Plus,
    Minus,
    EOF,
}

pub struct Tokenizer<'a> {
    src: &'a str,
    pos: usize,
}

impl<'a> Tokenizer<'a> {
    pub fn new(src: &'a str) -> Self {
        Self { src, pos: 0 }
    }

    pub fn tokenize(&mut self) -> Vec<Token> {
        let mut out = vec![];
        while let Some(ch) = self.src.chars().nth(self.pos) {
            self.pos += 1;
            match ch {
                '(' => out.push(Token::LParen),
                ')' => out.push(Token::RParen),
                '+' => out.push(Token::Plus),
                '-' => out.push(Token::Minus),
                c if c.is_ascii_digit() => out.push(Token::Number(c.to_string())),
                c if c.is_ascii_alphabetic() => out.push(Token::Ident(c.to_string())),
                c if c.is_whitespace() => {},
                _ => {}
            }
        }
        out.push(Token::EOF);
        out
    }
}
EOF

          ###############################################################
          # ast.rs
          ###############################################################
          cat << 'EOF' > src/ast.rs
#[derive(Debug)]
pub enum Expr {
    Number(i64),
    Ident(String),
    Binary {
        left: Box<Expr>,
        op: String,
        right: Box<Expr>,
    },
}
EOF

          ###############################################################
          # parser.rs
          ###############################################################
          cat << 'EOF' > src/parser.rs
use crate::tokenizer::Token;

pub struct Parser {
    tokens: Vec<Token>,
    pos: usize,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Self { tokens, pos: 0 }
    }

    fn current(&self) -> &Token {
        &self.tokens[self.pos]
    }
}
EOF

          ###############################################################
          # semantic.rs
          ###############################################################
          cat << 'EOF' > src/semantic.rs
pub struct SemanticAnalyzer;

impl SemanticAnalyzer {
    pub fn analyze() {
        // TODO: type system, meaning layer
    }
}
EOF

          ###############################################################
          # backend/mod.rs
          ###############################################################
          cat << 'EOF' > src/backend/mod.rs
pub mod cpp_codegen;
pub mod rust_macro_bridge;
EOF

          ###############################################################
          # backend/cpp_codegen.rs
          ###############################################################
          cat << 'EOF' > src/backend/cpp_codegen.rs
pub struct CppCodegen;

impl CppCodegen {
    pub fn emit() {
        // TODO: AST ‚Üí C++ template meta code
    }
}
EOF

          ###############################################################
          # backend/rust_macro_bridge.rs
          ###############################################################
          cat << 'EOF' > src/backend/rust_macro_bridge.rs
use crate::ast::Expr;

pub struct RustMacroBridge;

impl RustMacroBridge {
    pub fn expand(expr: &Expr) -> String {
        match expr {
            Expr::Number(n) => format!("sponge_num!({})", n),
            Expr::Ident(name) => format!("sponge_ident!(\"{}\")", name),
            Expr::Binary { left, op, right } => {
                let l = Self::expand(left);
                let r = Self::expand(right);
                format!("sponge_binop!({}, \"{}\", {})", l, op, r)
            }
        }
    }
}
EOF

          ###############################################################
          # include/sponge_meta.hpp
          ###############################################################
          cat << 'EOF' > include/sponge_meta.hpp
#pragma once

template<typename T>
struct sponge_meta {
    static void process() {
        // TODO meta operations
    }
};
EOF

          ###############################################################
          # include/meta_expand.hpp
          ###############################################################
          cat << 'EOF' > include/meta_expand.hpp
#pragma once

#include "sponge_meta.hpp"

template<typename T>
void meta_expand() {
    sponge_meta<T>::process();
}
EOF

          ###############################################################
          # example program
          ###############################################################
          echo 'print(1 + 2)' > examples/hello.sp


      #####################################################################
      # üî• 2. NASM / Clang ÏÑ§Ïπò
      #####################################################################
      - name: Install NASM + Clang (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y nasm clang

      - name: Install NASM + LLVM (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install nasm
          brew install llvm || true

      - name: Install NASM (Windows)
        if: runner.os == 'Windows'
        run: choco install nasm -y


      #####################################################################
      # üî• 3. Cargo Build
      #####################################################################
      - name: Cargo build
        run: cargo build --release


      #####################################################################
      # üî• 4. Run SpongeLang ‚Üí ASM
      #####################################################################
      - name: Generate ASM
        shell: bash
        run: |
          mkdir -p build
          ./target/release/sponge-meta-lang examples/hello.sp > build/out.asm


      #####################################################################
      # üî• 5. NASM ‚Üí Object File
      #####################################################################
      - name: Compile ASM with NASM
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            nasm -f win64 build/out.asm -o build/out.obj
          elif [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            nasm -f macho64 build/out.asm -o build/out.o
          else
            nasm -f elf64 build/out.asm -o build/out.o
          fi


      #####################################################################
      # üî• 6. C++ Template MetaLayer Compile Test (Linux/macOS)
      #####################################################################
      - name: C++ Meta Compile Test
        if: runner.os != 'Windows'
        shell: bash
        run: |
          mkdir -p cpp_test
          cat << 'EOF' > cpp_test/test.cpp
#include "../include/sponge_meta.hpp"
#include "../include/meta_expand.hpp"

int main() {
    meta_expand<int>();
    return 0;
}
EOF
          clang++ -std=c++20 cpp_test/test.cpp -o cpp_test/test


      #####################################################################
      # üî• 7. Artifact ZIP ÏÉùÏÑ±
      #####################################################################
      - name: Create OS Artifact ZIP
        shell: bash
        run: |
          mkdir -p artifact
          cp -r target/release artifact/
          cp -r build artifact/
          cp -r include artifact/
          zip -r ${RUNNER_OS,,}_build.zip artifact/*

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ runner.os }}-build
          path: ./*.zip



  ###########################################################################
  # RELEASE JOB
  ###########################################################################
  release:
    name: "üöÄ Auto Release + ProofLedger"
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: releases

      - name: Create SHA256 + ProofLedger
        shell: bash
        run: |
          echo "SpongeLang Release" > ProofLedger.txt
          echo "Generated: $(date -u)" >> ProofLedger.txt
          echo "" >> ProofLedger.txt
          for f in $(find releases -type f); do
            sha256sum "$f" >> ProofLedger.txt
          done

      - name: Bundle everything
        run: |
          zip -r full_bundle.zip releases/ ProofLedger.txt

      - name: Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: "SpongeLang ‚Äî ${{ github.ref_name }}"
          body: |
            Full Pipeline:
            - Auto Compiler Source Generation
            - Rust Macro Layer
            - C++20 Template Meta Layer
            - NASM Backend Build
            - Multi-OS Builds
            - SHA256 ProofLedger Included
          files: |
            full_bundle.zip
            releases/**/*.zip
            ProofLedger.txt
