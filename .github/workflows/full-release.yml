name: "ðŸ”¥ SpongeLang Full Build â€” Auto Generate + Rust Macro + C++ Meta + NASM + Release"

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    name: "ðŸ—ï¸ Auto Generate Compiler + Build (Rust Macro + C++ Meta + NASM)"
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # -----------------------------------------------------------
      # ðŸ”¥ 1. ëª¨ë“  SpongeLang ì»´íŒŒì¼ëŸ¬ ì†ŒìŠ¤ ìžë™ ìƒì„±
      # -----------------------------------------------------------

      - name: "Generate SpongeLang Compiler Files"
        shell: bash
        run: |
          mkdir -p src backend include examples src/backend

          # main.rs
          echo 'mod tokenizer;' > src/main.rs
          echo 'mod ast;' >> src/main.rs
          echo 'mod parser;' >> src/main.rs
          echo 'mod semantic;' >> src/main.rs
          echo 'mod backend;' >> src/main.rs
          echo '' >> src/main.rs
          echo 'use tokenizer::Tokenizer;' >> src/main.rs
          echo '' >> src/main.rs
          echo 'fn main() {' >> src/main.rs
          echo '    let input = std::fs::read_to_string("examples/hello.sp")' >> src/main.rs
          echo '        .expect("Failed to read file");' >> src/main.rs
          echo '' >> src/main.rs
          echo '    let tokens = Tokenizer::new(&input).tokenize();' >> src/main.rs
          echo '    println!("Tokens: {:?}", tokens);' >> src/main.rs
          echo '}' >> src/main.rs

          # tokenizer.rs
          echo '#[derive(Debug, Clone)]' > src/tokenizer.rs
          echo 'pub enum Token {' >> src/tokenizer.rs
          echo '    Ident(String),' >> src/tokenizer.rs
          echo '    Number(String),' >> src/tokenizer.rs
          echo '    LParen,' >> src/tokenizer.rs
          echo '    RParen,' >> src/tokenizer.rs
          echo '    Plus,' >> src/tokenizer.rs
          echo '    Minus,' >> src/tokenizer.rs
          echo '    EOF,' >> src/tokenizer.rs
          echo '}' >> src/tokenizer.rs
          echo '' >> src/tokenizer.rs
          echo 'pub struct Tokenizer<'"'"'a> {' >> src/tokenizer.rs
          echo '    src: &'"'"'a str,' >> src/tokenizer.rs
          echo '    pos: usize,' >> src/tokenizer.rs
          echo '}' >> src/tokenizer.rs
          echo '' >> src/tokenizer.rs
          echo 'impl<'"'"'a> Tokenizer<'"'"'a> {' >> src/tokenizer.rs
          echo '    pub fn new(src: &'"'"'a str) -> Self {' >> src/tokenizer.rs
          echo '        Self { src, pos: 0 }' >> src/tokenizer.rs
          echo '    }' >> src/tokenizer.rs
          echo '' >> src/tokenizer.rs
          echo '    pub fn tokenize(&mut self) -> Vec<Token> {' >> src/tokenizer.rs
          echo '        let mut out = vec![];' >> src/tokenizer.rs
          echo '        while let Some(ch) = self.src.chars().nth(self.pos) {' >> src/tokenizer.rs
          echo '            self.pos += 1;' >> src/tokenizer.rs
          echo '            match ch {' >> src/tokenizer.rs
          echo '                '('')'') => out.push(Token::LParen),' >> src/tokenizer.rs
          echo '                '('')'') => out.push(Token::RParen),' >> src/tokenizer.rs
          echo '                '+' => out.push(Token::Plus),' >> src/tokenizer.rs
          echo '                '-' => out.push(Token::Minus),' >> src/tokenizer.rs
          echo '                c if c.is_ascii_digit() => out.push(Token::Number(c.to_string())),' >> src/tokenizer.rs
          echo '                c if c.is_ascii_alphabetic() => out.push(Token::Ident(c.to_string())),' >> src/tokenizer.rs
          echo '                c if c.is_whitespace() => {},' >> src/tokenizer.rs
          echo '                _ => {}' >> src/tokenizer.rs
          echo '            }' >> src/tokenizer.rs
          echo '        }' >> src/tokenizer.rs
          echo '        out.push(Token::EOF);' >> src/tokenizer.rs
          echo '        out' >> src/tokenizer.rs
          echo '    }' >> src/tokenizer.rs
          echo '}' >> src/tokenizer.rs

          # ast.rs
          echo '#[derive(Debug)]' > src/ast.rs
          echo 'pub enum Expr {' >> src/ast.rs
          echo '    Number(i64),' >> src/ast.rs
          echo '    Ident(String),' >> src/ast.rs
          echo '    Binary {' >> src/ast.rs
          echo '        left: Box<Expr>,' >> src/ast.rs
          echo '        op: String,' >> src/ast.rs
          echo '        right: Box<Expr>,' >> src/ast.rs
          echo '    },' >> src/ast.rs
          echo '}' >> src/ast.rs

          # parser.rs
          echo 'use crate::tokenizer::Token;' > src/parser.rs
          echo '' >> src/parser.rs
          echo 'pub struct Parser {' >> src/parser.rs
          echo '    tokens: Vec<Token>,' >> src/parser.rs
          echo '    pos: usize,' >> src/parser.rs
          echo '}' >> src/parser.rs
          echo '' >> src/parser.rs
          echo 'impl Parser {' >> src/parser.rs
          echo '    pub fn new(tokens: Vec<Token>) -> Self {' >> src/parser.rs
          echo '        Self { tokens, pos: 0 }' >> src/parser.rs
          echo '    }' >> src/parser.rs
          echo '' >> src/parser.rs
          echo '    fn current(&self) -> &Token {' >> src/parser.rs
          echo '        &self.tokens[self.pos]' >> src/parser.rs
          echo '    }' >> src/parser.rs
          echo '}' >> src/parser.rs

          # semantic.rs
          echo 'pub struct SemanticAnalyzer;' > src/semantic.rs
          echo '' >> src/semantic.rs
          echo 'impl SemanticAnalyzer {' >> src/semantic.rs
          echo '    pub fn analyze() {' >> src/semantic.rs
          echo '        // TODO: meaning-based layer' >> src/semantic.rs
          echo '    }' >> src/semantic.rs
          echo '}' >> src/semantic.rs

          # backend/mod.rs
          echo 'pub mod cpp_codegen;' > src/backend/mod.rs
          echo 'pub mod rust_macro_bridge;' >> src/backend/mod.rs

          # backend/cpp_codegen.rs
          echo 'pub struct CppCodegen;' > src/backend/cpp_codegen.rs
          echo 'impl CppCodegen {' >> src/backend/cpp_codegen.rs
          echo '    pub fn emit() {' >> src/backend/cpp_codegen.rs
          echo '        // TODO: AST â†’ C++ meta template output' >> src/backend/cpp_codegen.rs
          echo '    }' >> src/backend/cpp_codegen.rs
          echo '}' >> src/backend/cpp_codegen.rs

          # backend/rust_macro_bridge.rs
          echo 'use crate::ast::Expr;' > src/backend/rust_macro_bridge.rs
          echo '' >> src/backend/rust_macro_bridge.rs
          echo 'pub struct RustMacroBridge;' >> src/backend/rust_macro_bridge.rs
          echo '' >> src/backend/rust_macro_bridge.rs
          echo 'impl RustMacroBridge {' >> src/backend/rust_macro_bridge.rs
          echo '    pub fn expand(expr: &Expr) -> String {' >> src/backend/rust_macro_bridge.rs
          echo '        match expr {' >> src/backend/rust_macro_bridge.rs
          echo '            Expr::Number(n) => format!("sponge_num!({})", n),' >> src/backend/rust_macro_bridge.rs
          echo '            Expr::Ident(name) => format!("sponge_ident!(\"{}\")", name),' >> src/backend/rust_macro_bridge.rs
          echo '            Expr::Binary { left, op, right } => {' >> src/backend/rust_macro_bridge.rs
          echo '                let l = Self::expand(left);' >> src/backend/rust_macro_bridge.rs
          echo '                let r = Self::expand(right);' >> src/backend/rust_macro_bridge.rs
          echo '                format!("sponge_binop!({}, \"{}\", {})", l, op, r)' >> src/backend/rust_macro_bridge.rs
          echo '            }' >> src/backend/rust_macro_bridge.rs
          echo '        }' >> src/backend/rust_macro_bridge.rs
          echo '    }' >> src/backend/rust_macro_bridge.rs
          echo '}' >> src/backend/rust_macro_bridge.rs

          # include/sponge_meta.hpp
          echo '#pragma once' > include/sponge_meta.hpp
          echo 'template<typename T>' >> include/sponge_meta.hpp
          echo 'struct sponge_meta {' >> include/sponge_meta.hpp
          echo '    static void process() {' >> include/sponge_meta.hpp
          echo '    }' >> include/sponge_meta.hpp
          echo '};' >> include/sponge_meta.hpp

          # include/meta_expand.hpp
          echo '#pragma once' > include/meta_expand.hpp
          echo 'template<typename T>' >> include/meta_expand.hpp
          echo 'void meta_expand() {' >> include/meta_expand.hpp
          echo '    sponge_meta<T>::process();' >> include/meta_expand.hpp
          echo '}' >> include/meta_expand.hpp

          # example
          echo 'print(1 + 2)' > examples/hello.sp

      # -----------------------------------------------------------
      # ðŸ”¥ 2. ì´ ì•„ëž˜ëŠ” ê¸°ì¡´ full pipeline (NASM + C++ Meta + Release)
      # -----------------------------------------------------------

      - name: Install NASM + Clang (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y nasm clang

      - name: Install NASM + LLVM (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install nasm
          brew install llvm || true

      - name: Install NASM (Windows)
        if: runner.os == 'Windows'
        run: choco install nasm -y

      - name: Cargo build â€” SpongeLang Compiler
        run: cargo build --release

      - name: Run SpongeLang â†’ ASM
        shell: bash
        run: |
          mkdir -p build
          ./target/release/sponge-meta-lang examples/hello.sp > build/out.asm

      - name: Compile ASM with NASM
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            nasm -f win64 build/out.asm -o build/out.obj
          elif [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            nasm -f macho64 build/out.asm -o build/out.o
          else
            nasm -f elf64 build/out.asm -o build/out.o
          fi

      - name: C++ Meta Compile Test (Linux/macOS)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          mkdir -p cpp_test
          echo '#include "../include/sponge_meta.hpp"' > cpp_test/test.cpp
          echo '#include "../include/meta_expand.hpp"' >> cpp_test/test.cpp
          echo 'int main() { meta_expand<int>(); return 0; }' >> cpp_test/test.cpp
          clang++ -std=c++20 cpp_test/test.cpp -o cpp_test/test
          echo "C++ meta layer OK"

      - name: Create OS Artifact ZIP
        shell: bash
        run: |
          mkdir -p artifact
          cp -r target/release artifact/
          cp -r build artifact/
          cp -r include artifact/
          zip -r ${RUNNER_OS,,}_build.zip artifact/*

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ runner.os }}-build
          path: ./*.zip

  release:
    name: "ðŸš€ Auto Release + ProofLedger"
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: releases

      - name: Create ProofLedger + SHA256
        shell: bash
        run: |
          echo "SpongeLang Release Pipeline" > ProofLedger.txt
          echo "Generated: $(date -u)" >> ProofLedger.txt
          echo "" >> ProofLedger.txt
          for f in $(find releases -type f); do
            sha256sum "$f" >> ProofLedger.txt
          done

      - name: Bundle everything
        run: |
          zip -r full_bundle.zip releases/ ProofLedger.txt

      - name: Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: "SpongeLang Full Pipeline â€” ${{ github.ref_name }}"
          body: |
            Full pipeline generated automatically:
            - Auto source creation
            - Rust Macro Layer
            - C++ Template Meta Layer
            - NASM Backend
            - Multi-OS Build
            - ProofLedger with SHA256
          files: |
            full_bundle.zip
            releases/**/*.zip
            ProofLedger.txt
