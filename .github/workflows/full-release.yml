name: "SpongeLang Full Build - Auto Generate + NASM + C++ Meta + Release"

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    name: "Build"
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
    matrix:
      os: [ubuntu-latest, macos-latest, windows-latest]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate compiler files
        shell: bash
        run: |
          mkdir -p src/backend include examples

          # main.rs
          cat << 'EOF' > src/main.rs
mod tokenizer;
mod ast;
mod parser;
mod semantic;
mod backend;

use tokenizer::Tokenizer;

fn main() {
    let input = std::fs::read_to_string("examples/hello.sp")
        .expect("Failed to read file");

    let tokens = Tokenizer::new(&input).tokenize();
    println!("Tokens: {:?}", tokens);
}
EOF

          # tokenizer.rs
          cat << 'EOF' > src/tokenizer.rs
#[derive(Debug, Clone)]
pub enum Token {
    Ident(String),
    Number(String),
    LParen,
    RParen,
    Plus,
    Minus,
    EOF,
}

pub struct Tokenizer<'a> {
    src: &'a str,
    pos: usize,
}

impl<'a> Tokenizer<'a> {
    pub fn new(src: &'a str) -> Self {
        Self { src, pos: 0 }
    }

    pub fn tokenize(&mut self) -> Vec<Token> {
        let mut out = vec![];
        while let Some(ch) = self.src.chars().nth(self.pos) {
            self.pos += 1;
            match ch {
                '(' => out.push(Token::LParen),
                ')' => out.push(Token::RParen),
                '+' => out.push(Token::Plus),
                '-' => out.push(Token::Minus),
                c if c.is_ascii_digit() => out.push(Token::Number(c.to_string())),
                c if c.is_ascii_alphabetic() => out.push(Token::Ident(c.to_string())),
                c if c.is_whitespace() => {},
                _ => {}
            }
        }
        out.push(Token::EOF);
        out
    }
}
EOF

          # ast.rs
          cat << 'EOF' > src/ast.rs
#[derive(Debug)]
pub enum Expr {
    Number(i64),
    Ident(String),
    Binary {
        left: Box<Expr>,
        op: String,
        right: Box<Expr>,
    },
}
EOF

          # parser.rs
          cat << 'EOF' > src/parser.rs
use crate::tokenizer::Token;

pub struct Parser {
    tokens: Vec<Token>,
    pos: usize,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Self { tokens, pos: 0 }
    }

    fn current(&self) -> &Token {
        &self.tokens[self.pos]
    }
}
EOF

          # semantic.rs
          cat << 'EOF' > src/semantic.rs
pub struct SemanticAnalyzer;

impl SemanticAnalyzer {
    pub fn analyze() {
        // TODO
    }
}
EOF

          # backend/mod.rs
          cat << 'EOF' > src/backend/mod.rs
pub mod cpp_codegen;
pub mod rust_macro_bridge;
EOF

          # backend/cpp_codegen.rs
          cat << 'EOF' > src/backend/cpp_codegen.rs
pub struct CppCodegen;

impl CppCodegen {
    pub fn emit() {
        // TODO
    }
}
EOF

          # backend/rust_macro_bridge.rs
          cat << 'EOF' > src/backend/rust_macro_bridge.rs
use crate::ast::Expr;

pub struct RustMacroBridge;

impl RustMacroBridge {
    pub fn expand(expr: &Expr) -> String {
        match expr {
            Expr::Number(n) => format!("sponge_num!({})", n),
            Expr::Ident(name) => format!("sponge_ident!(\"{}\")", name),
            Expr::Binary { left, op, right } => {
                let l = Self::expand(left);
                let r = Self::expand(right);
                format!("sponge_binop!({}, \"{}\", {})", l, op, r)
            }
        }
    }
}
EOF

          # include/sponge_meta.hpp
          cat << 'EOF' > include/sponge_meta.hpp
#pragma once

template<typename T>
struct sponge_meta {
    static void process() { }
};
EOF

          # include/meta_expand.hpp
          cat << 'EOF' > include/meta_expand.hpp
#pragma once
#include "sponge_meta.hpp"

template<typename T>
void meta_expand() {
    sponge_meta<T>::process();
}
EOF

          echo "print(1 + 2)" > examples/hello.sp

      # ------------ Install NASM & C++ toolchain --------------------
      - name: Install NASM (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y nasm clang

      - name: Install NASM (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install nasm
          brew install llvm || true

      - name: Install NASM (Windows)
        if: runner.os == 'Windows'
        run: choco install nasm -y

      # ------------ Cargo Build --------------------
      - name: Build Rust compiler
        run: cargo build --release

      # ------------ Generate ASM --------------------
      - name: Generate ASM
        shell: bash
        run: |
          mkdir -p build
          ./target/release/sponge-meta-lang examples/hello.sp > build/out.asm

      # ------------ NASM Compile --------------------
      - name: NASM compile
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            nasm -f win64 build/out.asm -o build/out.obj
          elif [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            nasm -f macho64 build/out.asm -o build/out.o
          else
            nasm -f elf64 build/out.asm -o build/out.o
          fi

      # ------------ C++ Meta Test --------------------
      - name: C++ Meta Test
        if: runner.os != 'Windows'
        shell: bash
        run: |
          mkdir -p cpp_test
          cat << 'EOF' > cpp_test/test.cpp
#include "../include/sponge_meta.hpp"
#include "../include/meta_expand.hpp"
int main() {
    meta_expand<int>();
    return 0;
}
EOF
          clang++ -std=c++20 cpp_test/test.cpp -o cpp_test/test

      # ------------ Artifact -------------------------
      - name: Package Artifact
        shell: bash
        run: |
          mkdir -p artifact
          cp -r target/release artifact/
          cp -r build artifact/
          cp -r include artifact/
          zip -r ${RUNNER_OS,,}_build.zip artifact/*

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ runner.os }}-build
          path: ./*.zip


  release:
    name: "Release + Ledger"
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: releases

      - name: Generate ProofLedger
        shell: bash
        run: |
          echo "SpongeLang Release" > ProofLedger.txt
          echo "Generated: $(date -u)" >> ProofLedger.txt
          for f in $(find releases -type f); do
            sha256sum "$f" >> ProofLedger.txt
          done

      - name: Bundle everything
        run: zip -r full_bundle.zip releases/ ProofLedger.txt

      - name: Publish Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: "SpongeLang Release â€” ${{ github.ref_name }}"
          body: |
            Auto-generated compiler pipeline:
            - Rust Macro Layer
            - C++ Template Meta Layer
            - NASM backend
            - Multi-OS Build
            - SHA256 ProofLedger
          files: |
            full_bundle.zip
            releases/**/*.zip
            ProofLedger.txt
